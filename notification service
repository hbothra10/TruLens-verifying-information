import { supabase } from '../lib/supabase';

export interface Notification {
  id: string;
  content: string;
  content_type: 'text' | 'media' | 'url';
  verdict: 'TRUE' | 'FALSE' | 'MISLEADING' | 'NEEDS_VERIFICATION';
  authenticity_score: number;
  reasoning: string;
  key_findings: string[];
  corrected_statement?: string;
  sources: Array<{
    name: string;
    url: string;
    credibility: string;
  }>;
  user_id: string;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateNotificationInput {
  content: string;
  content_type: 'text' | 'media' | 'url';
  verdict: 'TRUE' | 'FALSE' | 'MISLEADING' | 'NEEDS_VERIFICATION';
  authenticity_score: number;
  reasoning: string;
  key_findings: string[];
  corrected_statement?: string;
  sources: Array<{
    name: string;
    url: string;
    credibility: string;
  }>;
}

function getUserId(): string {
  let userId = localStorage.getItem('trulens-user-id');
  if (!userId) {
    userId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem('trulens-user-id', userId);
  }
  return userId;
}

export async function createNotification(input: CreateNotificationInput): Promise<Notification | null> {
  const { data, error } = await supabase
    .from('notifications')
    .insert({
      content: input.content,
      content_type: input.content_type,
      verdict: input.verdict,
      authenticity_score: input.authenticity_score,
      reasoning: input.reasoning,
      key_findings: input.key_findings,
      corrected_statement: input.corrected_statement,
      sources: input.sources,
      user_id: getUserId(),
      is_read: false,
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating notification:', error);
    return null;
  }

  return data as Notification;
}

export async function getNotifications(): Promise<Notification[]> {
  const { data, error } = await supabase
    .from('notifications')
    .select('*')
    .eq('user_id', getUserId())
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching notifications:', error);
    return [];
  }

  return data as Notification[];
}

export async function getUnreadCount(): Promise<number> {
  const { count, error } = await supabase
    .from('notifications')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', getUserId())
    .eq('is_read', false);

  if (error) {
    console.error('Error fetching unread count:', error);
    return 0;
  }

  return count || 0;
}

export async function markAsRead(notificationId: string): Promise<boolean> {
  const { error } = await supabase
    .from('notifications')
    .update({ is_read: true })
    .eq('id', notificationId)
    .eq('user_id', getUserId());

  if (error) {
    console.error('Error marking notification as read:', error);
    return false;
  }

  return true;
}

export async function markAllAsRead(): Promise<boolean> {
  const { error } = await supabase
    .from('notifications')
    .update({ is_read: true })
    .eq('user_id', getUserId())
    .eq('is_read', false);

  if (error) {
    console.error('Error marking all notifications as read:', error);
    return false;
  }

  return true;
}

export async function deleteNotification(notificationId: string): Promise<boolean> {
  const { error } = await supabase
    .from('notifications')
    .delete()
    .eq('id', notificationId)
    .eq('user_id', getUserId());

  if (error) {
    console.error('Error deleting notification:', error);
    return false;
  }

  return true;
}

export function determineVerdict(authenticityScore: number): 'TRUE' | 'FALSE' | 'MISLEADING' {
  if (authenticityScore >= 70) return 'TRUE';
  if (authenticityScore >= 50) return 'MISLEADING';
  return 'FALSE';
}
